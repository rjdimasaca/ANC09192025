/**
 * @NApiVersion 2.x
 * @NScriptType MapReduceScript
 * @Author TC010
 * @Email netrodsuite@gmail.com / rmdimasaca@cloudtecherp.com
 * @Project ANC
 * @Date December 11, 2019
 * @Filename 010MR_deleteLimsAndJournals.js
 * @version 1.0.0 - TC10ROD
 * 
 * TODO : this can be enhanced to merge the results, because the TRANSACTION may be deleted already from previous execution.
 * TRANSACTIONS can be involved in different searches
 * FOR now execute them one search at a time, it will eventually get rid of the transactions, so at time of execution, script will not try to get rid of something that has already been removed
 */

define(['N/runtime', 'N/record', 'N/file', 'N/runtime', 'N/email', 'N/search'], function(runtime, record, file, runtime, email, search) {
	
	var startDate_global = new Date().getTime();
	
	var script = runtime.getCurrentScript();
	var submissionId = script.getParameter({ name: 'custscript_dlaj_submissionid'}) || startDate_global;
	
	var defaultEmailMessage = "<br/><b>This is an autogenerated email, please do not reply.</b><br/>"
	
  /**
   * Passes the data passed from
   *
   * @param {*} context
   */
  function getData(context) {
	  
	  var currentUser = runtime.getCurrentUser();
	  var currentUser_id = currentUser.id;
//	  log.debug("currentUser_id", currentUser_id);
	  
	  if(currentUser_id)
	  {
		  email.send({
	          author: currentUser_id,
	          recipients: [currentUser_id],
	          subject: "Deleting LIMS and Transactions" + submissionId,
	          body: "Deleting LIMS and Transactions Started." + defaultEmailMessage
	      });
	  }
	  
    var script = runtime.getCurrentScript();
    var data = [];
    var searchIds = script.getParameter({ name: 'custscript_searchids'}) || "[]";
    if(searchIds)
    {
    	searchIds = JSON.parse(searchIds);
    }
    log.debug("searchIds", searchIds);
    for(var a = 0 ; a < searchIds.length ; a++)
    {
    	data.push(searchIds[a]);
    	log.debug("searchIds[a]", searchIds[a]);
    }
    log.debug("data", data);
    return data;
  }
  
  function emailTheIssue(emailBody)
	{
		var currentUser = runtime.getCurrentUser();
		  var currentUser_id = currentUser.id;
//		  log.debug("currentUser_id", currentUser_id);
		  
		try
		{
			if(emailBody)
			{
//				email.send({
//			          author: currentUser_id,
//			          recipients: [currentUser_id],
//			          subject: "Deleting LIMS and Transactions" + submissionId,
//			          body: JSON.stringify(emailBody) + defaultEmailMessage
//			      });
			}
		}
		catch(e)
		{
			log.error("ERROR in function emailTheIssue", e.message);
		}
	}
	
	function emailTheSummary(emailBody, searchId)
	{
		var currentUser = runtime.getCurrentUser();
		  var currentUser_id = currentUser.id;
//		  log.debug("currentUser_id", currentUser_id);
		  
		
		log.debug("emailing the summary")
		try
		{
			if(emailBody)
			{
				email.send({
			          author: currentUser_id,
			          recipients: [currentUser_id],
			          subject: "Deleting LIMS and Transactions" + submissionId,
			          body: "summary for search id : " + searchId + "<br/>" + JSON.stringify(emailBody) + defaultEmailMessage
			      });
			}
		}
		catch(e)
		{
			log.error("ERROR in function emailTheIssue", e.message);
		}
	}
  
  var getResults = function getResults(set) {
      var holder = [];
      var i = 0;
      while (true) {
        var result = set.getRange({
          start: i,
          end: i + 1000
        });
        if (!result) break;
        holder = holder.concat(result);
        if (result.length < 1000) break;
        i += 1000;
      }
      return holder;
    };

  /**
   *
   */
  function mapData(context) {
    var data = (context.value);
    /* log.audit({
      title: 'MAP_EXEC',
      details: JSON.stringify(data)
    }); */
	var searchId = data;
    var searchObj_results = [];
    try {
    	if(searchId)
    	{
    		var searchObj = search.load({
        		id : searchId
        	})
        	if(searchObj)
        	{
        		searchObj_results = getResults(searchObj.run())
        	}
    	}
    	
    	//log.debug("TC10RODmapData data", data);
    } catch (e) {
    	
    }
    
    log.debug("mapData : data", data)
    context.write({
      key: searchId,
      value: searchObj_results
    });
  }

  /**
   * Create sales order and group line item by client site
   * @param {context} object reduce context object
   * @param {string} object.key the key that was used for grouping
   * @param {array} object.values the values mapped to the given key
   */
  function processData(context)
  {
	  try
	  {
		  log.debug("REDUCE! function processData : context", context);
		  log.debug("REDUCE! function processData : context.values", context.values);
		  for(var a = 0 ; a < context.values.length ; a++)
		  {
			  log.debug("REDUCE! function processData : context.values[a]", context.values[a]);
			  var entryToDelete = context.values[a];
			  entryToDelete = JSON.parse(entryToDelete);
			  log.debug("entryToDelete", entryToDelete)
			  log.debug("entryToDelete.length", entryToDelete.length);
			  var deletedJes = [];
			  var deletedJes_unique = [];
			  var deletedJes_actual_withduplicates = [];
			  var deletedLims = [];
			  var deletedLims_noTransaction = [];
			  var deletedJes_actual = [];
			  var deletedLims_actual = [];
			  var deletedLims_actual_withduplicates = [];
			  
			  var lims_failedAttemptOfActualDeletion = [];
			  var transactions_failedAttemptOfActualDeletion = [];
			  
			  for(var b = 0 ; b < entryToDelete.length ; b++)
			  {
				  var lookupTransaction = {};
//				  log.debug("REDUCE! function processData : entryToDelete[b]", entryToDelete[b]);
				  
				//custrecord_synclims_nsid may have a value but the actual transaction may have been deleted, use custrecord_trans_ref instead
//				  var entry_jeId  = entryToDelete[b].values.custrecord_synclims_nsid;
//				  var entry_jeId  = entryToDelete[b].values.custrecord_trans_ref;
				  var entry_jeId  = entryToDelete[b].values.custrecord_trans_ref && entryToDelete[b].values.custrecord_trans_ref.length > 0 && entryToDelete[b].values.custrecord_trans_ref[0].value ? entryToDelete[b].values.custrecord_trans_ref[0].value : "";
				  var entry_limsId  = entryToDelete[b].id;
				  var entry_limsRecordType  = entryToDelete[b].recordType;
				  var transactionDeletionSuccessful = false;

				  deletedJes.push(entry_jeId);
				  if(entry_jeId && deletedJes_unique.indexOf(entry_jeId) == -1)
				  {
					  deletedJes_unique.push(entry_jeId);
				  }
				  
				  if(entry_jeId)
				  {
					  lookupTransaction = search.lookupFields({
						  type: "transaction",
						  id : entry_jeId,
						  columns : ["recordtype"]
					  });
				  }
				  
				  if(entry_jeId && deletedJes_actual.indexOf(entry_jeId) == -1)
				  {
					  //try to delete TODO
					  try
					  {
						//actually delete the TRANSACTIONS here TODO uncomment when kath is ready
						  var entry_jeId_actual = record.delete({
							  type: lookupTransaction.recordtype,
							  id : entry_jeId,
						  })
						  deletedJes_actual.push(entry_jeId_actual);
//						  deletedJes_actual.push(entry_jeId);
						  
						  //this just loads record, just for testing so we see if any record is valid, this was done for the mean development, because we dont want to delete the actual data
//						  var transactionRecord = record.load({
//							  type: lookupTransaction.recordtype,
//							  id: entry_jeId,
//						  });
//						  log.debug("transactionRecord", transactionRecord);
						  //TODO actually delete the transaction here
						  transactionDeletionSuccessful = true;
					  }
					  catch(e)
					  {
						  log.debug("ATTEMPTED TO DELETE", {transactionId : entry_jeId});
						  log.debug("ERROR in trying to delete entry", e.message);
						  transactionDeletionSuccessful = false;
						  var issueDetails = {type : entry_limsRecordType, id : entry_limsId, message : e.message, category : lookupTransaction};
						  log.debug("FAILED TO DELETE TRANSACTION ENTRY : ", issueDetails)
						  
						  transactions_failedAttemptOfActualDeletion.push(issueDetails);
						  emailTheIssue(issueDetails);
					  }
					  log.debug("evaluating records", {entry_limsId : entry_limsId, entry_jeId : entry_jeId, lookupTransaction : lookupTransaction})
				  }
				  //collect the ones with duplicate so we can compare
				  else
				  {
					  //collect all valid jeId
					  if(entry_jeId)
					  {
						  deletedJes_actual_withduplicates.push(entry_jeId);
					  }
					  
					  //actually delete the lims here TODO uncomment when kath is ready
					  try
					  {
						  var entry_limsId_actual = record.delete({
							  type : entry_limsRecordType,
							  id : entry_limsId
						  })
						  log.debug("DELETE SYNC TABLE ENTRY(actual with dups) : entry_limsId_actual", entry_limsId_actual)
						  deletedLims_actual_withduplicates.push(entry_limsId_actual);
//						  deletedLims_actual_withduplicates.push(entry_limsId);
					  }
					  catch(e)
					  {
						  log.debug("FAILED TO DELETE SYNC TABLE ENTRY(actual with dups) : ", {type : entry_limsRecordType, id : entry_limsId, message : e.message})
						  var issueDetails = {type : entry_limsRecordType, id : entry_limsId, message : e.message, category : "(actual with dups)"};
						  lims_failedAttemptOfActualDeletion.push(issueDetails);
						  emailTheIssue(issueDetails);
					  }
				  }
				  
				  //only remove lims if there is transaction and if it has been succesfully removed
				  if(transactionDeletionSuccessful && entry_jeId)
				  {
					 if(deletedLims_actual.indexOf(entry_limsId) == -1) 
					 {
						//actually delete the lims here TODO uncomment when kath is ready
						 try
						 {
							  var entry_limsId_actual = record.delete({
								  type : entry_limsRecordType,
								  id : entry_limsId
							  });
							  log.debug("DELETE SYNC TABLE ENTRY(actual with dups) : entry_limsId_actual", entry_limsId_actual)
							  deletedLims_actual.push(entry_limsId_actual);
//							  deletedLims_actual.push(entry_limsId);
						 }
						 catch(e)
						 {
							 log.debug("FAILED TO DELETE SYNC TABLE ENTRY(actual with no dups) : ", {type : entry_limsRecordType, id : entry_limsId, message : e.message});
							 var issueDetails = {type : entry_limsRecordType, id : entry_limsId, message : e.message, category : "(actual with no dups)"};
							 lims_failedAttemptOfActualDeletion.push(issueDetails);
							 emailTheIssue(issueDetails);
						 }
					 }
				  }
				  
				  //collect all lims with no entry_jeId at all because they have to be removed as well
				  if(!entry_jeId) 
				  {
					  //TODO actually delete the lims here NO NEED TO DELETE, these are covered by deletedLims_actual_withduplicates
					  deletedLims_noTransaction.push(entry_limsId);
				  }
				  
				  //still collect all lims so we can compare
				  if(deletedLims.indexOf(entry_limsId) == -1) 
				  {
					  deletedLims.push(entry_limsId);
				  }
			  }
			  log.debug("deletedLims", deletedLims);
			  log.debug("deletedJes", deletedJes);
			  log.debug("deletedLims.length", deletedLims.length);
			  log.debug("deletedJes.length", deletedJes.length);
			  

			  log.debug("deletedLims_actual", deletedLims_actual);
			  log.debug("deletedJes_actual", deletedJes_actual);
			  log.debug("deletedLims_actual.length", deletedLims_actual.length);
			  log.debug("deletedJes_actual.length", deletedJes_actual.length);
			  
			  log.debug("deletedLims_noTransaction", deletedLims_noTransaction);
			  log.debug("deletedLims_noTransaction.length", deletedLims_noTransaction.length);
			  
			  log.debug("deletedJes_unique", deletedJes_unique);
			  log.debug("deletedJes_unique.length", deletedJes_unique.length);
			  
			  log.debug("deletedJes_actual_withduplicates", deletedJes_actual_withduplicates);
			  log.debug("deletedJes_actual_withduplicates.length", deletedJes_actual_withduplicates.length);
			  
			  log.debug("deletedLims_actual_withduplicates", deletedLims_actual_withduplicates);
			  log.debug("deletedLims_actual_withduplicates.length", deletedLims_actual_withduplicates.length);
			  
			  log.debug("transactions_failedAttemptOfActualDeletion", transactions_failedAttemptOfActualDeletion);
			  log.debug("transactions_failedAttemptOfActualDeletion.length", transactions_failedAttemptOfActualDeletion.length);

			  log.debug("lims_failedAttemptOfActualDeletion", lims_failedAttemptOfActualDeletion);
			  log.debug("lims_failedAttemptOfActualDeletion.length", lims_failedAttemptOfActualDeletion.length);
			  
			  var summary = {
					  transactionActualDeletions : deletedJes_actual.length,
					  limsActualDeletions : deletedLims_actual.length + deletedLims_actual_withduplicates.length,
					  lims_failedAttemptOfActualDeletion : lims_failedAttemptOfActualDeletion.length,
					  transactions_failedAttemptOfActualDeletion : transactions_failedAttemptOfActualDeletion.length,
					  entryToDelete : entryToDelete.length,
				  };
			  log.debug("SUMMARY : ", summary)
			  
//			  log.debug("emailing the summary")
//				try
//				{
//					if(emailBody)
//					{
//						email.send({
//					          author: currentUser_id,
//					          recipients: [currentUser_id],
//					          subject: "Deleting LIMS and JES summary",
//					          body: JSON.stringify(summary)
//					      });
//					}
//				}
//				catch(e)
//				{
//					log.error("ERROR in function emailTheSummary", e.message);
//				}
			  emailTheSummary(summary, context.key);
		  }
	  }
	  catch(e)
	  {
		  log.error("ERROR in function processData", e.stack);
		  emailTheIssue(e.stack)
	  }
  }


  return {
    getInputData: getData,
    map: mapData,
    reduce: processData
  };
});